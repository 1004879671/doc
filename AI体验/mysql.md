# MySQL表级锁和行级锁如何使用

## 1. MySQL表级锁

表级锁概述
- 表级锁是一种锁定数据表的机制，可以锁定整张表的读写操作。
- 当一个事务对一张表进行操作时，会对整张表加锁，其他事务无法对该表进行任何操作。
- 表级锁适用于对表进行大量操作的场景，如表的结构变更等。
- 但是，表级锁会影响并发性能，因为其他事务无法同时对该表进行操作。

表级锁的优点和缺点
- 表级锁的优点：
  - 实现简单，资源消耗小
  - 可以有效地避免死锁的发生
- 表级锁的缺点：
  - 并发性差，会导致大量的请求被阻塞
  - 锁粒度大，影响粒度较大的数据操作性能

如何在MySQL中使用表级锁- 使用LOCK TABLES语句对表进行加锁，例如：

```
LOCK TABLES table_name READ;
```

- 在执行完操作后使用UNLOCK TABLES语句解锁表，例如：

```
UNLOCK TABLES;
```

- 可以同时对多个表进行加锁，例如：

```
LOCK TABLES table1 READ, table2 WRITE;
```

- 在使用表级锁时，需要注意以下几点：

  - 不能在一个事务中使用LOCK TABLES语句和SELECT、INSERT、UPDATE、DELETE语句混合使用；
  - 在使用LOCK TABLES语句时，其他的线程将无法访问被锁定的表，可能会导致性能问题；
  - 在使用LOCK TABLES语句时，需要注意锁的粒度，避免对不必要的表进行加锁。

## 2. MySQL行级锁

行级锁概述
- 行级锁是MySQL中一种用于控制并发访问的锁机制，它可以在SQL操作期间锁定表中的某些行，以防止其他事务对这些行进行修改或删除。
- 行级锁可以分为共享锁和排他锁两种类型，共享锁允许多个事务同时读取同一行数据，而排他锁则只允许一个事务对某一行进行修改。
- 行级锁的优点是可以提高并发性能，缩短锁定时间，但也可能会导致死锁等问题，需要开发人员在使用时注意。

行级锁的优点和缺点
- 行级锁的优点：
  - 并发度高：不同的行上的数据可以被不同的事务同时修改。
  - 粒度小：锁定的粒度最小，只锁定需要修改的行，不会造成不必要的锁定，提高了系统的并发性能。
  - 准确性高：只有真正需要修改的数据才会被锁定，不会对其他数据造成影响。
- 行级锁的缺点：
  - 加锁时间长：由于需要锁定的粒度最小，所以需要加锁的时间也最长，容易造成死锁。
  - 锁定资源多：由于每个需要修改的行都需要加锁，所以在高并发的情况下，会造成大量的锁定资源，影响系统的性能。

如何在MySQL中使用行级锁- 为了在MySQL中使用行级锁，可以使用以下语句来开启事务：

```sql
START TRANSACTION;
```

- 在需要加锁的语句前面加上`SELECT ... FOR UPDATE`或者`SELECT ... FOR SHARE`，例如：

```sql
SELECT * FROM table WHERE id = 1 FOR UPDATE;
```

- `FOR UPDATE`会在读取该行数据时给该行加上排他锁，其他事务无法修改该行数据，直到当前事务提交或回滚。

- `FOR SHARE`会在读取该行数据时给该行加上共享锁，其他事务可以读取该行数据，但无法修改该行数据，直到当前事务提交或回滚。

- 在事务结束时，使用以下语句提交或回滚事务：

```sql
COMMIT;
```

或者

```sql
ROLLBACK;
```

## 3. MySQL表级锁和行级锁的比较

性能比较
- 性能比较：

  以表级锁为例，当一个表被锁定时，其他的查询都必须等待锁释放才能执行，这会导致并发性能降低。而行级锁只会锁定需要修改的行，其他行不受影响，可以提高并发性能。

  举例来说，假设有一个表格包含1000行数据，同时有两个用户在对这个表格进行操作，一个用户要修改第一行数据，另一个用户要修改第二行数据。如果使用表级锁，当一个用户在修改第一行数据时，整个表格都会被锁定，另一个用户必须等待第一个用户操作完成后才能进行修改。而如果使用行级锁，当一个用户在修改第一行数据时，只有第一行数据被锁定，另一个用户可以同时修改第二行数据，不会被阻塞。

  因此，在高并发的情况下，行级锁能够提高数据库的性能。

并发性比较
- 表级锁的例子：
  
  ```
  LOCK TABLES table_name WRITE;
  -- 对整张表进行加锁，其他线程无法读写该表，直到当前线程释放锁
  -- 适用于需要对整张表进行操作的场景，如表的结构变更等
  ```

- 行级锁的例子：

  ```
  START TRANSACTION;
  SELECT * FROM table_name WHERE id = 1 FOR UPDATE;
  -- 对表中id为1的行进行加锁，其他线程无法修改该行，直到当前线程释放锁
  -- 适用于需要对特定行进行操作的场景，如订单等
  ```

- 表级锁会导致并发性能下降的例子：

  ```
  -- 线程1
  LOCK TABLES table_name WRITE;
  -- 对整张表进行加锁，其他线程无法读写该表，直到当前线程释放锁

  -- 线程2
  LOCK TABLES table_name WRITE;
  -- 等待线程1释放锁

  -- 线程3
  SELECT * FROM table_name;
  -- 无法读取表，等待线程1和线程2释放锁
  ```

- 行级锁可以提高并发性能的例子：

  ```
  -- 线程1
  START TRANSACTION;
  SELECT * FROM table_name WHERE id = 1 FOR UPDATE;
  -- 对表中id为1的行进行加锁，其他线程无法修改该行，直到当前线程释放锁
  
  -- 线程2
  START TRANSACTION;
  SELECT * FROM table_name WHERE id = 2 FOR UPDATE;
  -- 对表中id为2的行进行加锁，不会与线程1冲突，提高并发性能
  
  -- 线程3
  SELECT * FROM table_name WHERE id = 1;
  -- 可以读取表中id为1的行，但无法修改，等待线程1释放锁
  ```- 并发性比较
  - 表级锁：
    - 当一个线程获得表级锁时，其他线程不能对该表进行任何操作，包括读和写，因此并发性较差。
    - 示例：在一个高并发的在线商城系统中，当一个用户在下单时，其他用户不能进行购买操作，因为下单需要获得表级锁。
  - 行级锁：
    - 当一个线程获得某行的行级锁时，其他线程只能对该行进行读操作，不能进行写操作，因此并发性较好。
    - 示例：在一个高并发的社交网络系统中，当一个用户在发布动态时，其他用户仍然可以浏览该用户的主页，因为发布动态只需要获得该行的行级锁。

使用场景比较- 表级锁适用于对表进行大量批量操作的场景，如批量更新、删除等操作。

  ```
  -- 示例：对整张表进行更新操作
  UPDATE table_name SET column_name = 'new_value' WHERE condition;
  ```

- 行级锁适用于对表进行频繁的单行操作的场景，如同时对同一行进行读写操作。

  ```
  -- 示例：对同一行进行读写操作
  -- 事务A
  BEGIN;
  SELECT * FROM table_name WHERE id = 1 FOR UPDATE;
  -- 对id为1的行进行更新操作
  UPDATE table_name SET column_name = 'new_value' WHERE id = 1;
  COMMIT;
  
  -- 事务B
  BEGIN;
  SELECT * FROM table_name WHERE id = 1 FOR UPDATE;
  -- 对id为1的行进行更新操作
  UPDATE table_name SET column_name = 'another_value' WHERE id = 1;
  COMMIT;
  ```